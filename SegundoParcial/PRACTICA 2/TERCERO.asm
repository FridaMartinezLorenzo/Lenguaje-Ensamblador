;programa para Masm QUE OBTIENE UN NUMERO ALEATORIO
   ; ESTE PROGRAMA CALCULA UN NUMERO ALEATORIO BASADO
   ; EN OTRO NUMERO ALEATORIO PREVIO O SEMILLA, COLOCADO EN DX
   ;Y LA SALIDA SE OBTIENE EN AX, EL NUMERO ALEATORIO ES DE 16 BITS

; Definicion de stack
STACKSG segment para stack 'stack'
        DB 20 DUP (0)
STACKSG ENDS

;DEFINICION DE AREAS DE TRABAJO
DATASG SEGMENT PARA 'DATA'
SALTA db 13, 10,'$'
MEN6 DB 'SEMILLA PARA EL NUMERO$'
MEN2 DB 'ADIOS$'
SUMH DB ?
SUML DB ?
MEN4 DB "ERROR,INGRESE HEXADECIMAL VALIDO !!$"
DATASG ENDS

CODESG SEGMENT PARA 'CODE'
PRINCI PROC FAR
   ASSUME SS:STACKSG, DS:DATASG,CS:CODESG
   ;PROTOCOLO
   PUSH DS
   SUB AX,AX
   PUSH AX
   MOV AX,SEG DATASG
   MOV DS,AX

   ;INICIA PROGRAMA
   MOV CH,00H
   MOV SUMH,CH
   MOV SUML,CH
   MOV CX,10
OTRO:   PUSH CX
   CALL SEMILLA
   CALL ALEATORIO
   CALL ESCALANDO
   ;NUMERO ALEATORIO EN AL
   ;MOV DL,AL
   ;CALL DESEMPAQUETA
   PUSH DX
   CLC
   MOV DH,SUMH
   MOV DL,SUML
   ADD DL,AL
   ADC DH,0H
   MOV SUMH,DH
   MOV SUML,DL
   POP DX
   CALL LEE
   
   
   MOV DL,SUMH
   CALL DESEMPAQUETA
   MOV DL,SUML
   CALL DESEMPAQUETA
   CALL ALIMENTAR_LINEA
   
   POP CX
   LOOP OTRO
   CALL SALIR_DOS
PRINCI ENDP



SEMILLA PROC
PUSH AX
MOV AH,2CH
INT 21H  ; RETORNA CH=HORAS, EN FORMATO 00-23, MEDIANOCHE=0
         ; CL MINUTOS 00-59
         ;DH SEGUNDOS 00-59
         ;DL CENTESIMAS DE SEGUNDO 00-99
POP AX
RET
SEMILLA ENDP

ALEATORIO PROC
; XN+1=(2053*XN + 13849)MOD 2**16
; RETORNA EL NUMERO PSEUDOALEATORIO EN AX
MOV AX,DX ;CARGANDO A AX EL NUMERO SEMILLA tomado de la int 21 serv             2CH
MOV DX,0  ;CARGANDO CERO EN LA POSICION MAS SIGNIFICATIVA DEL               MULTIPLICANDO
MOV BX,2053 ; MULTIPLICADOR
MUL BX
MOV BX,13849 ;CARGA EN BX LA CONSTANTE ADITIVA
CLC ;limpiar la bandera de CARRY
ADD AX,BX ; SUMA PARTES MENOS SIGNIFICATIVAS DEL RESULTADO
ADC DX,0 ; SUMA EL ACARREO SI ES NECESARIO
MOV BX,0FFFFH ; CARGAR LA CONSTANTE 2**16-1
DIV BX
MOV AX,DX ; MUEVE EL RESIDUO  AX
RET
ALEATORIO ENDP


ESCALANDO PROC
   ; ESCALANDO EL NUMERO PSEUDOALEATORIO OBTENIDO
   MOV DX,0
   MOV BX,64H;NUMEROS ALEATORIOS ENTRE 0 Y 9
   DIV BX
   MOV AX,DX
   MOV BX,0000
   MOV DL,AL
   CALL DESEMPAQUETA
   ;CALL ALIMENTAR_LINEA
   ;CALL DESEMPAQUETA_SIN_IMP
   ;MOV DL,BL
   ;CALL DESEMPAQUETA
   
   RET
ESCALANDO ENDP

LEE PROC
   MOV AH,01
   INT 21H
RET
LEE ENDP

ESCRIBE PROC
   MOV AH,02
   INT 21H
 RET
ESCRIBE ENDP

SALIR_DOS PROC
   MOV AH,4CH
   INT 21H
RET
SALIR_DOS ENDP

    ;SUBRUTINA1
   escribe_cadena PROC
    PUSH AX
    MOV AH,09
    INT 21H
    POP AX
    RET
   escribe_cadena ENDP
    
   ;SUBRUTINA2
   leer_car_con_eco PROC
    MOV AH,01 ;no podemos resguardar ax en esa subrutina porque se pierde el char
    INT 21H
    RET
   leer_car_con_eco ENDP
   
   ;SUBRUTINA3
   leer_car_sin_eco PROC
   MOV AH,08
    INT 21H
    RET
    leer_car_sin_eco ENDP 
    
    ;SUBRUTINA4
   escribe_car_ PROC
        PUSH AX
        MOV AH,02 ;CARACTER ALMACENADO EN DL
        INT 21H
        POP AX
        RET
        escribe_car_ ENDP 
    
    ;SUBRUTINA5
   sal_a_dos PROC
   MOV AH,4CH
    INT 21H
    RET
   sal_a_dos ENDP
   
   ;SUBRUTINA6
   alimentar_linea PROC
    PUSH DX
    MOV DL,0AH
    CALL ESCRIBE_CAR_
    MOV DL,0DH
    CALL ESCRIBE_CAR_
    POP DX
    RET
   alimentar_linea ENDP
   
   ;SUBRUTINA7 CODIGO ASCII_BINARIO
    ASCII_BINARIO PROC ;EL DATO SE GUARDA EN AL
    CMP AL,30H
    JL ERROR
    CMP AL,39H
    JG LETRA
    SUB AL,30H ;RESTAR 30 QUE ES EL 0
    JMP FIN
   LETRA:
      CMP AL,41H
      JL ERROR
      CMP AL,46H
      JG ERROR
      SUB AL,37H ; RESTAR 37 QUE ES EL VALOR DE "A"
      JMP FIN
   ERROR:
      MOV AL,00
      LEA DX,SALTA
      CALL INVALID_HEXA
      CALL SAL_A_DOS
   FIN:
      RET
   ASCII_BINARIO ENDP
   
   
   BINARIO_ASCII PROC
    CMP DL,9H
    JG SUMA37
    ADD DL,30H
    JMP DESENLACE
   SUMA37:
     ADD DL,37H ;el dato se va a quedar en DL
   DESENLACE: 
     RET
   BINARIO_ASCII ENDP
   
   EMPAQUETA PROC
    PUSH CX                 ;shift left compromete al registro cx como contador
    CALL LEER_CAR_CON_ECO
    CALL ASCII_BINARIO      ;PROCESA EL 1ER CARACTER
    MOV CL,04
    SHL AL,CL               ;INSTRUCCION LOGICA DE CORRIMIENTO A LA IZQ
    MOV CH,AL               ;ALMACENANDO EL VALOR DE AL A UN REGISTRO AUX
    CALL LEER_CAR_CON_ECO   ;LEER L SEGUNDO CAR
    CALL ASCII_BINARIO      ;PROCESA EL 2O. CARACTER
    ADD AL,CH               ;la subrutina empaqueta deja la suma en al
    POP CX
    RET
    EMPAQUETA ENDP   ;LO DEJA EN AL
   
   
   DESEMPAQUETA PROC
   PUSH DX
   PUSH CX
   MOV DH,DL ; GUARDANDO EL VALOR ORIGINAL DE DH
   MOV CL,4
   SHR DL,CL ; CUATRO CORRIMIENTOS A LA DERECHA
   CALL BINARIO_ASCII
   CALL ESCRIBE_CAR_
   MOV DL,DH
   AND DL,0FH ;RECUPERANDO EL DATO DE DH
   CALL BINARIO_ASCII
   CALL ESCRIBE_CAR_
   POP CX
   POP DX
   RET
   DESEMPAQUETA ENDP
   
   DESEMPAQUETA_Y_GUARDA PROC
   PUSH DX
   PUSH CX
   MOV DL,BH
   MOV DH,DL ; GUARDANDO EL VALOR ORIGINAL DE DH
   MOV CL,4
   SHR DL,CL ; CUATRO CORRIMIENTOS A LA DERECHA
   CALL BINARIO_ASCII
   MOV [SI],DL
   INC SI
   MOV DL,DH
   AND DL,0FH ;RECUPERANDO EL DATO DE DH
   CALL BINARIO_ASCII  ;EL DATO SE QUEDA EN DL
   MOV [SI],DL
   INC SI
   ;SEGUNDO NIBLE
   MOV DL,BL
   MOV DH,DL ; GUARDANDO EL VALOR ORIGINAL DE DH
   MOV CL,4
   SHR DL,CL ; CUATRO CORRIMIENTOS A LA DERECHA
   CALL BINARIO_ASCII
   MOV [SI],DL
   INC SI
   MOV DL,DH
   AND DL,0FH ;RECUPERANDO EL DATO DE DH
   CALL BINARIO_ASCII  ;EL DATO SE QUEDA EN DL
   MOV [SI],DL
   INC SI

   POP CX
   POP DX
   RET
   DESEMPAQUETA_Y_GUARDA ENDP
   
   READ_DATA PROC
       PUSH DX
       LEA DX,SALTA
       CALL ESCRIBE_CADENA
       CALL ALIMENTAR_LINEA
       LEA DX,MEN2
       CALL ESCRIBE_CADENA
       CALL EMPAQUETA
       MOV BH,AL
       CALL EMPAQUETA
       MOV BL,AL
       CALL ALIMENTAR_LINEA
       POP DX
       RET
   READ_DATA ENDP
   
   ES_PAR_VERI PROC
    PUSH BX
    MOV BX,0002H
    IDIV BX
    CMP DX,0000H
    JE PAR
    ;PROCEDIMIENTO IMPAR
    MOV CH,00H ;CH ES LA BANDERA, 0 IMPAR
    JMP LAST_STEP
    PAR:
        MOV CH,01H; CH 1 ES PAR
    LAST_STEP:
        POP BX
        RET
   ES_PAR_VERI ENDP
   
   VALIDAR_INICIO1 PROC
    CMP AL,00H
    JLE NONONO
    MOV CH,01H
    JMP EXIT
    NONONO:
        MOV CH,00H
        CALL INVALID_HEXA
    EXIT:
        RET
   VALIDAR_INICIO1 ENDP
   
   INVALID_HEXA PROC
      LEA DX,SALTA
      CALL ESCRIBE_CADENA
      CALL ALIMENTAR_LINEA
      LEA DX,MEN4
      CALL ESCRIBE_CADENA
      CALL ALIMENTAR_LINEA
      CALL SAL_A_DOS
      RET
   INVALID_HEXA ENDP
   
   DESEMPAQUETA_SIN_IMP PROC
   PUSH DX
   PUSH CX
   MOV DH,AL ; GUARDANDO EL VALOR ORIGINAL DE DH
   MOV CL,4
   SHR DL,CL ; CUATRO CORRIMIENTOS A LA DERECHA
   CALL BINARIO_ASCII
   MOV BL,DL
   MOV DL,BL
   ;CALL ESCRIBE_CAR_
   MOV DL,DH
   AND DL,0FH ;RECUPERANDO EL DATO DE DH
   CALL BINARIO_ASCII
   MOV BH,BL
   MOV BL,DL
   ADD BH,BL
   MOV DL,BH
   CALL ESCRIBE_CAR_
   POP CX
   POP DX
   RET
   DESEMPAQUETA_SIN_IMP ENDP ;GUARDA NUEVO DATO EN BL
   
CODESG ENDS
        END PRINCI